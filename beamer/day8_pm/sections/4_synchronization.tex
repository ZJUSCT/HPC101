\section{Shared Data Synchronization}

\subsection{Race Conditions}
\begin{frame}[fragile]{\emoji{racing-car} Race Condition Demonstration (1/2)}
	\textbf{The Problem}: Multiple threads accessing shared data simultaneously

	\begin{minted}{cpp}
int counter = 0;  // Shared global variable

void increment_unsafe(int iterations) {
    for(int i = 0; i < iterations; i++) {
        counter++;  // NOT thread-safe!
    }
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{racing-car} Race Condition Demonstration (2/2)}
	\textbf{Threading Code}:

	\begin{minted}{cpp}
// Create 4 threads, each incrementing 100000 times
std::vector<std::thread> threads;
for(int i = 0; i < 4; i++) {
    threads.emplace_back(increment_unsafe, 100000);
}

// Wait for completion
for(auto& t : threads) {
    t.join();
}

std::cout << "Expected: 400000" << std::endl;
std::cout << "Actual:   " << counter << std::endl;
	\end{minted}

	\textbf{Expected}: 400000 \quad \textbf{Typical actual}: 387234 (varies!)
\end{frame}

\begin{frame}[fragile]{\emoji{microscope} Why Race Conditions Happen}
	\textbf{Assembly Analysis of} \texttt{counter++}:

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{C++ Code}
			\begin{minted}{cpp}
counter++;
			\end{minted}

			\vspace{1em}
			\textbf{Assembly (x86-64)}
			\begin{minted}{asm}
mov    eax, DWORD PTR [counter]
add    eax, 1
mov    DWORD PTR [counter], eax
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Thread Interleaving}
			\begin{table}[h]
				\tiny
				\begin{tabular}{|l|l|l|}
					\hline
					\textbf{Thread 1}  & \textbf{Thread 2}  & \textbf{counter} \\
					\hline
					mov eax, [counter] &                    & 0                \\
					(eax = 0)          &                    & 0                \\
					                   & mov eax, [counter] & 0                \\
					                   & (eax = 0)          & 0                \\
					add eax, 1         &                    & 0                \\
					(eax = 1)          &                    & 0                \\
					                   & add eax, 1         & 0                \\
					                   & (eax = 1)          & 0                \\
					mov [counter], eax &                    & 1                \\
					                   & mov [counter], eax & 1                \\
					\hline
				\end{tabular}
			\end{table}

			\textbf{Result}: Both threads read 0, both write 1
			\\Expected: 2, Actual: 1
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{Critical Section}: The portion of code that accesses shared resources
\end{frame}

\subsection{Mutexes and RAII}
\begin{frame}[fragile]{\emoji{lock} From C Mutexes to C++ RAII Locks}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{C pthread Mutex}
			\begin{minted}{c}
pthread_mutex_t mutex =
  PTHREAD_MUTEX_INITIALIZER;
void* increment_safe(void* arg) {
    int iterations = *(int*)arg;
    for(int i = 0; i < iterations; i++) {
        pthread_mutex_lock(&mutex);
        counter++;
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}
// Manual cleanup required
pthread_mutex_destroy(&mutex);
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{C++ RAII Lock}
			\begin{minted}{cpp}
std::mutex mtx;
void increment_safe(int iterations) {
    for(int i = 0; i < iterations; i++) {
        std::lock_guard<std::mutex>
          lock(mtx);
        counter++;
        // Auto unlock at scope end
    }
}// Automatic cleanup!
			\end{minted}
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{RAII Benefits}: Exception Safety • No Manual Management • Scope-based
\end{frame}

\begin{frame}[fragile]{\emoji{hammer-and-wrench} Fixed Counter Example (1/2)}
	\begin{minted}{cpp}
std::mutex counter_mutex;
int counter = 0;

void increment_safe(int iterations) {
    for(int i = 0; i < iterations; i++) {
        std::lock_guard<std::mutex> lock(counter_mutex);
        counter++;  // Now thread-safe!
    }
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{hammer-and-wrench} Fixed Counter Example (2/2)}
	\textbf{Usage}:

	\begin{minted}{cpp}
// Same threading code as before
std::vector<std::thread> threads;
for(int i = 0; i < 4; i++) {
    threads.emplace_back(increment_safe, 100000);
}

for(auto& t : threads) {
    t.join();
}

std::cout << "Expected: 400000" << std::endl;
std::cout << "Actual:   " << counter << std::endl;
// Result: Success: Y (always!)
	\end{minted}
\end{frame}

\subsection{Deadlock Prevention}
\begin{frame}[fragile]{\emoji{skull} Deadlock: The Four Horsemen}
	\textbf{Deadlock Conditions} (All must be present):
	\begin{enumerate}
		\item \textbf{Mutual Exclusion}: Resources cannot be shared
		\item \textbf{Hold and Wait}: Process holds resource while waiting for another
		\item \textbf{No Preemption}: Resources cannot be forcibly taken
		\item \textbf{Circular Wait}: Circular chain of waiting processes
	\end{enumerate}

	\vspace{1em}
	\textbf{Classic Deadlock Example}:
	\begin{minted}{cpp}
std::mutex mutex1, mutex2;
void thread1() {
    std::lock_guard<std::mutex> lock1(mutex1);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> lock2(mutex2);  // Waits forever
    // Do work...
}
void thread2() {
    std::lock_guard<std::mutex> lock2(mutex2);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> lock1(mutex1);  // Waits forever
    // Do work...
}
	\end{minted}

	\emoji{warning} \textbf{Result}: Both threads wait forever!
\end{frame}

\begin{frame}[fragile]{\emoji{shield} Deadlock Prevention: Strategy 1}
	\textbf{Ordered Locking}

	\begin{minted}{cpp}
std::mutex mutex1, mutex2;

void thread1() {
    std::lock_guard<std::mutex> lock1(mutex1);  // Same order
    std::lock_guard<std::mutex> lock2(mutex2);
    // Do work...
}

void thread2() {
    std::lock_guard<std::mutex> lock1(mutex1);  // Same order
    std::lock_guard<std::mutex> lock2(mutex2);
    // Do work...
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{shield} Deadlock Prevention: Strategy 2}
	\textbf{Atomic Multi-lock}

	\begin{minted}{cpp}
void thread1() {
    std::unique_lock<std::mutex> lock1(mutex1, std::defer_lock);
    std::unique_lock<std::mutex> lock2(mutex2, std::defer_lock);

    std::lock(lock1, lock2);  // Atomic acquisition
    // Do work...
}  // Automatic release

void thread2() {
    // ... same pattern ...
    std::lock(lock1, lock2);  // Same atomic acquisition
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{bank} Bank Transfer: Class Definition}
	\begin{minted}{cpp}
class BankAccount {
private:
    double balance;
    mutable std::mutex mtx;

public:
    BankAccount(double initial) : balance(initial) {}

    double get_balance() const {
        std::lock_guard<std::mutex> lock(mtx);
        return balance;
    }

    // Safe transfer using ordered locking
    static void transfer(BankAccount& from, BankAccount& to,
                        double amount);
};
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{bank} Bank Transfer: Implementation}
	\begin{minted}{cpp}
void BankAccount::transfer(BankAccount& from, BankAccount& to,
                          double amount) {
    // Prevent deadlock with consistent lock ordering
    if (&from < &to) {
        std::lock_guard<std::mutex> lock1(from.mtx);
        std::lock_guard<std::mutex> lock2(to.mtx);
        from.balance -= amount;
        to.balance += amount;
    } else {
        std::lock_guard<std::mutex> lock1(to.mtx);
        std::lock_guard<std::mutex> lock2(from.mtx);
        from.balance -= amount;
        to.balance += amount;
    }
}

// Usage: BankAccount::transfer(alice, bob, 100);
	\end{minted}
\end{frame}
