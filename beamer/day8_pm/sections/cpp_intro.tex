\section{C++ Quick Start}

\subsection{C++ vs C: Key Differences}
\begin{frame}[fragile]{\emoji{gear} C++ vs C: Core Differences}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{C Style}
			\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

void print_msg(void) {
    printf("Hello from C!\n");
}

int main() {
    FILE* fp = fopen("test.txt", "r");
    if (fp) {
        // Manual resource management
        fclose(fp);
    }
    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{C++ Style}
			\begin{minted}{cpp}
#include <iostream>
#include <fstream>

void print_msg() {
    std::cout << "Hello from C++!" << std::endl;
}

class FileHandler {
public:
    FileHandler(const char* fname)
        : fp(std::fopen(fname, "r")) {}
    ~FileHandler() { if(fp) std::fclose(fp); }
private:
    FILE* fp;
};

int main() {
    FileHandler fh("test.txt");  // RAII
    return 0;
}
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{\emoji{link} References vs Pointers}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{C Pointers}
			\begin{minted}{c}
void swap_c(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    swap_c(&x, &y);  // Pass addresses
    printf("x=%d, y=%d\n", x, y);
    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{C++ References}
			\begin{minted}{cpp}
void swap_cpp(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap_cpp(x, y);  // Direct pass
    std::cout << "x=" << x << ", y=" << y << std::endl;
    return 0;
}
			\end{minted}
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{Key Differences:}
	\begin{itemize}
		\item References must be initialized and cannot be reassigned
		\item No pointer arithmetic with references
		\item Cleaner syntax for function parameters
	\end{itemize}
\end{frame}

\subsection{Essential Features for Concurrency}
\begin{frame}[fragile]{\emoji{rocket} Lambda Expressions: The Core of Thread Functions}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{C Function Pointers}
			\begin{minted}{c}
#include <pthread.h>

void* thread_func(void* arg) {
    int id = *(int*)arg;
    printf("Thread %d running\n", id);
    return NULL;
}

int main() {
    pthread_t thread;
    int id = 1;
    pthread_create(&thread, NULL,
                   thread_func, &id);
    pthread_join(thread, NULL);
    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{C++ Lambda}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>

int main() {
    int id = 1;

    // Lambda expression
    auto thread_func = [id]() {
        std::cout << "Thread " << id
                  << " running" << std::endl;
    };

    std::thread t(thread_func);
    t.join();

    return 0;
}
			\end{minted}
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{Lambda Capture Modes:}
	\begin{itemize}
		\item \texttt{[]} - Capture nothing
		\item \texttt{[=]} - Capture by value
		\item \texttt{[\&]} - Capture by reference
		\item \texttt{[id]} - Capture specific variable by value
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\emoji{brain} Auto Type Deduction \& Smart Pointers}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{Auto Type Deduction}
			\begin{minted}{cpp}
#include <vector>
#include <map>

int main() {
    auto x = 42;              // int
    auto y = 3.14;            // double
    auto str = "Hello";       // const char*

    std::vector<int> vec{1,2,3};
    auto it = vec.begin();    // vector<int>::iterator

    // Complex types made simple
    std::map<std::string, int> m;
    for(auto& pair : m) {     // Range-based for
        std::cout << pair.first << std::endl;
    }

    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Smart Pointers}
			\begin{minted}{cpp}
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Created\n"; }
    ~Resource() { std::cout << "Destroyed\n"; }
};

int main() {
    // Automatic memory management
    auto ptr = std::make_unique<Resource>();

    // Shared ownership
    auto shared1 = std::make_shared<Resource>();
    auto shared2 = shared1;  // Reference count: 2

    // Automatic cleanup when out of scope
    return 0;
}
			\end{minted}
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{Benefits:}
	\begin{itemize}
		\item Automatic memory management
		\item Exception safety
		\item Clear ownership semantics
	\end{itemize}
\end{frame}
