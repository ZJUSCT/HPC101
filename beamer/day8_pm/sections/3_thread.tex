\section{<thread>}

\begin{frame}[fragile]{Thread}
    \begin{minted}{cpp}
template< class F, class... Args >
    explicit thread( F&& f, Args&&... args );
thread( thread&& other ) noexcept; // Move constructor
    \end{minted}
    \begin{itemize}
        \item \texttt{other}: another thread object to construct this thread object with
        \item \texttt{f}: Callable object to execute in the new thread
        \item \texttt{args}: Arguments to pass to the new function
    \end{itemize}
\end{frame}



\begin{frame}[fragile]{C++ Thread Lifecycle Management}
	\textbf{C++ Advantages:}
	\begin{itemize}
		\item Type-safe parameter passing
		\item RAII automatic resource management
		\item Exception safety
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{RAII Thread Guard}
	\textbf{Problem:} Exception-safe thread management

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{Without RAII - Dangerous!}
			\begin{minted}{cpp}
void do_work() {
    std::thread t([]() {
        // long running task
    });

    // If exception thrown here,
    // t.join() won't be called!
    risky_operation();

    t.join();  // May not be reached
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{With RAII - Safe!}
			\begin{minted}{cpp}
class thread_guard {
    std::thread& t;
public:
    explicit thread_guard(std::thread& t_)
        : t(t_) {}

    ~thread_guard() {
        if(t.joinable()) {
            t.join();
        }
    }

    thread_guard(const thread_guard&) = delete;
    thread_guard& operator=(const thread_guard&) = delete;
};

void do_work() {
    std::thread t([]() {
        // long running task
    });
    thread_guard g(t);

    risky_operation();  // Safe!
    // Destructor ensures join()
}
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{\emoji{thread} C++ Thread Creation: Basics and Pitfalls}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{Basic Thread Creation}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>

void worker(int id) {
    std::cout << "Worker " << id
              << " running" << std::endl;
}

int main() {
    std::thread t(worker, 42);

    // Must join or detach!
    t.join();  // Wait for completion

    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Most Vexing Parse Problem}
			\begin{minted}{cpp}
struct background_task {
    void operator()() {
        // do work
    }
};

// WRONG! This declares a function!
std::thread my_thread(background_task());

// Correct ways:
std::thread t1{background_task()};  // uniform init
std::thread t2((background_task())); // extra parentheses
std::thread t3(background_task{});   // temporary object

// Lambda is often clearer:
std::thread t4([](){
    // do work
});
			\end{minted}
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{Key Points:}
	\begin{itemize}
		\item C++ interprets ambiguous syntax as function declarations
		\item Use uniform initialization \texttt{\{\}} or extra parentheses
		\item Lambdas avoid the parsing issue entirely
	\end{itemize}
    \begin{columns}
	\begin{column}{0.5\textwidth}
		\textbf{C++ std::thread Example}
		\begin{minted}{cpp}
#include <thread>
#include <vector>
#include <iostream>

void worker(int id) {
    std::cout << "Worker " << id
              << " running" << std::endl;
}

int main() {
    std::vector<std::thread> threads;

    // Create threads
    for(int i = 0; i < 4; i++) {
        threads.emplace_back(worker, i);
    }

    // Wait for completion
    for(auto& t : threads) {
        t.join();
    }

    return 0;
}
			\end{minted}
	\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{C++ Advantages:}
	\begin{itemize}
		\item Type-safe parameter passing
		\item RAII automatic resource management
		\item Exception safety
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\emoji{warning} Parameter Passing: By Value vs Reference}
	\textbf{Key Principle:} Thread constructor copies arguments as rvalues

	\begin{minted}{cpp}
#include <thread>
#include <iostream>
#include <string>

void print_string(const std::string& str) {
    std::cout << str << std::endl;
}

void increment(int& val) {
    val++;
}

int main() {
    char buffer[] = "Hello World";

    // DANGEROUS! Pointer passed, conversion happens in new thread
    // Original buffer might be destroyed before conversion
    // std::thread t1(print_string, buffer);

    // SAFE! Force conversion before thread creation
    std::thread t1(print_string, std::string(buffer));

    int x = 42;

    // WRONG! Can't pass reference directly
    // std::thread t2(increment, x);

    // CORRECT! Use std::ref to pass reference
    std::thread t2(increment, std::ref(x));

    t1.join();
    t2.join();

    std::cout << "Final x: " << x << std::endl;  // x is now 43
    return 0;
}
	\end{minted}
	\begin{minted}{cpp}
#include <thread>
#include <iostream>
#include <vector>

void print_value(int val) {
    std::cout << "Value: " << val << std::endl;
}

void increment(int& val) {
    val++;
}

int main() {
    int x = 42;

    // Pass by value - safe
    std::thread t1(print_value, x);

    // This won't compile - can't pass reference directly
    // std::thread t2(increment, x);

    // Correct way to pass reference
    std::thread t2(increment, std::ref(x));

    // Dangerous - reference to local variable
    std::vector<std::thread> threads;
    for(int i = 0; i < 3; i++) {
        // threads.emplace_back(print_value, i);  // Dangerous!
        threads.emplace_back(print_value, i);     // OK - copy
    }

    t1.join();
    t2.join();

    for(auto& t : threads) {
        t.join();
    }

    std::cout << "Final x: " << x << std::endl;
    return 0;
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{laptop} Hands-on: Multi-threaded Array Sum}
	\textbf{Task}: Calculate sum of array using multiple threads

	\begin{minted}{cpp}
#include <thread>
#include <vector>
#include <numeric>
#include <iostream>

void partial_sum(const std::vector<int>& arr,
                 size_t start, size_t end,
                 long long& result) {
    result = 0;
    for(size_t i = start; i < end; i++) {
        result += arr[i];
    }
}

int main() {
    const size_t SIZE = 1000000;
    std::vector<int> data(SIZE, 1);  // All elements = 1

    const int NUM_THREADS = 4;
    std::vector<std::thread> threads;
    std::vector<long long> partial_results(NUM_THREADS, 0);

    size_t chunk_size = SIZE / NUM_THREADS;

    // Create worker threads
    for(int i = 0; i < NUM_THREADS; i++) {
        size_t start = i * chunk_size;
        size_t end = (i == NUM_THREADS-1) ? SIZE : (i+1) * chunk_size;

        threads.emplace_back(partial_sum, std::cref(data),
                           start, end, std::ref(partial_results[i]));
    }

    // Wait for completion and sum results
    for(auto& t : threads) {
        t.join();
    }

    long long total = std::accumulate(partial_results.begin(),
                                    partial_results.end(), 0LL);

    std::cout << "Total sum: " << total << std::endl;
    return 0;
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{arrow-right} Transferring Ownership with Move}
	\textbf{Move Semantics:} Transfer unique resources to threads

	\begin{minted}{cpp}
#include <thread>
#include <memory>
#include <iostream>

void process_data(std::unique_ptr<int> ptr) {
    if (ptr) {
        std::cout << "Processing: " << *ptr << std::endl;
        *ptr *= 2;
        std::cout << "Result: " << *ptr << std::endl;
    }
}

int main() {
    auto ptr = std::make_unique<int>(42);

    // Transfer ownership to thread using std::move
    std::thread t(process_data, std::move(ptr));

    // ptr is now nullptr, ownership transferred
    assert(ptr == nullptr);

    t.join();
    return 0;
}
	\end{minted}

	\vspace{1em}
	\textbf{Thread ID Management:}
	\begin{minted}{cpp}
#include <thread>
#include <iostream>

int main() {
    std::thread t([]() {
        std::cout << "Thread ID: " << std::this_thread::get_id() << std::endl;
    });

    std::cout << "Main thread ID: " << std::this_thread::get_id() << std::endl;
    std::cout << "Worker thread ID: " << t.get_id() << std::endl;

    t.join();
    return 0;
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{light-bulb} Best Practices Summary}
	\textbf{Thread Management Checklist:}

	\begin{enumerate}
		\item \textbf{Always handle thread lifecycle:} Call \texttt{join()} or \texttt{detach()}
		\item \textbf{Use RAII:} Wrap threads in guard classes for exception safety
		\item \textbf{Be careful with parameter passing:}
		      \begin{itemize}
			      \item Force conversions before thread creation
			      \item Use \texttt{std::ref()} for references
			      \item Use \texttt{std::move()} for unique resources
		      \end{itemize}
		\item \textbf{Avoid the most vexing parse:} Use \texttt{\{\}} or lambdas
		\item \textbf{Make threads self-contained:} Copy needed data into thread
	\end{enumerate}

	\vspace{1em}
	\textbf{Key Concepts:}
	\begin{itemize}
		\item \textbf{RAII}: Resource Acquisition Is Initialization
		\item \textbf{Joinable}: Thread can be waited for completion
		\item \textbf{Detached}: Thread runs independently, no control
		\item \textbf{Thread ID}: Unique identifier for each thread
	\end{itemize}
\end{frame}
