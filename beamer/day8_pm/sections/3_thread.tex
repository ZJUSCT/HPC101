\section{<thread>}

\subsection{Basic Thread Management}

\begin{frame}[fragile]{Launching a Thread}
	\textbf{C++ Thread Constructor:}
	\begin{minted}{cpp}
template< class F, class... Args >
    explicit thread( F&& f, Args&&... args );
thread( thread&& other ) noexcept; // Move constructor
    \end{minted}
	\begin{itemize}
		\item \texttt{other}: another thread object to construct this thread object with
		\item \texttt{f}: Callable object to execute in the new thread
		\item \texttt{args}: Arguments to pass to the new function
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Launching a Thread - Basic Examples}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{Simple Function}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>

void hello() {
    cout << "Hello from thread!"
              << endl;
}

int main() {
    thread t(hello);
    t.join();
    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Function with Parameters}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>

void worker(int id, const string& name) {
    cout << "Worker " << id
              << " (" << name << ") running"
              << endl;
}

int main() {
    thread t(worker, 42, "Alice");
    t.join();
    return 0;
}
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Launching a Thread - Function Objects and Lambdas}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{Function Object}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>

class background_task {
public:
    void operator()() {
        cout << "Background task running"
                  << endl;
    }
};

int main() {
    background_task task;
    thread t(task);
    t.join();
    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Lambda Expression}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>

int main() {
    thread t([]() {
        cout << "Lambda task running"
                  << endl;
    });

    t.join();
    return 0;
}
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{\emoji{warning} Most Vexing Parse Problem}
	\textbf{Common Pitfall:} C++ interprets ambiguous syntax as function declarations

	\begin{minted}{cpp}
struct background_task {
    void operator()() {
        // do work
    }
};

// WRONG! This declares a function, not creates a thread!
thread my_thread(background_task());

// Correct ways:
thread t1{background_task()};    // uniform initialization
thread t2((background_task()));  // extra parentheses
thread t3(background_task{});    // temporary object
	\end{minted}

	\textbf{Recommended:} Use uniform initialization \texttt{\{\}} or lambdas to avoid parsing issues
\end{frame}

\begin{frame}[fragile]{Waiting for a Thread to Complete}
	\textbf{join():} Wait for thread completion before continuing

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
void worker(int seconds) {
    this_thread::sleep_for(
        chrono::seconds(seconds));
    cout << "Work done!" << endl;
}
int main() {
    cout << "Starting thread..." << endl;
    thread t(worker, 2);
    cout << "Waiting for completion..."
              << endl;
    t.join();  // Block until thread finishes
    cout << "Thread completed!" << endl;
    return 0;
}
			\end{minted}
			\textbf{Basic join() Example}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
void worker(int id) {
    cout << "Worker " << id
              << " running" << endl;
}
int main() {
    vector<thread> threads;
    for(int i = 0; i < 4; i++) {
        threads.emplace_back(worker, i);
    }
    for(auto& t : threads) {
        t.join();
    }
    cout << "All threads completed!"
              << endl;
    return 0;
}
			\end{minted}
			\textbf{Multiple Threads}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Waiting in Exceptional Circumstances}
	\textbf{Problem:} Exception-safe thread management with RAII

	\begin{columns}
		\begin{column}{0.4\textwidth}
			\begin{minted}{cpp}
void do_work() {
    thread t([]() {
        // long running task
    });

    // If exception thrown here,
    // t.join() won't be called!
    risky_operation();

    t.join();  // May not be reached
}
			\end{minted}
			\textbf{Without RAII - Dangerous!}
		\end{column}
		\begin{column}{0.6\textwidth}
			\begin{minted}{cpp}
class thread_guard {
    thread& t;
public:
    explicit thread_guard(thread& t_) : t(t_) {}
    ~thread_guard() { if(t.joinable()) { t.join(); } }
    thread_guard(const thread_guard&) = delete;
    thread_guard& operator=(const thread_guard&) = delete;
};
void do_work() {
    thread t([]() { /* long running task */ });
    thread_guard g(t);
    risky_operation();  // Safe!
    // Destructor ensures join()
}
			\end{minted}
			\textbf{With RAII - Safe!}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Running Threads in the Background}
	\textbf{detach():} Run thread independently without waiting

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
int main() {
    thread t(background_task);

    // Detach - thread runs independently
    t.detach();

    cout << "Main continues..." << endl;

    // Main might end before background finishes!
    this_thread::sleep_for(
        chrono::seconds(3));

    return 0;
}
			\end{minted}
			\textbf{Detached Thread Example}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
thread t(worker);
// Check if thread can be joined
if (t.joinable()) {
    cout << "Thread is joinable"
                << endl;
    t.join();
}
// After join/detach, not joinable
cout << "Joinable: " << t.joinable()
            << endl;  // false
thread t2(worker);
t2.detach();
cout << "Detached joinable: "
    << t2.joinable() << endl;  // false
			\end{minted}
			\textbf{Checking Thread State}
		\end{column}
	\end{columns}

	\scriptsize
	\textbf{Important:} Every thread must be either joined or detached before destruction!
\end{frame}

\subsection{Passing Arguments to a Thread Function}

\begin{frame}[fragile]{Parameter Passing Basics}
	\textbf{Key Principle:} Thread constructor copies arguments as rvalues
	\textbf{String Conversion Issues}
	\begin{columns}
		\begin{column}{0.6\textwidth}
			\begin{minted}{cpp}
void print_string(const string& str) {
    cout << str << endl;
}

// UNSAFE! Pointer passed, conversion happens in new thread
thread unsafe_executor() {
    char buffer[] = "Hello World";
    return thread(print_string, buffer);
}
// SAFE! Force conversion before thread creation
thread safe_executor() {
    char buffer[] = "Hello World";
    return thread(print_string, string(buffer));
}
			\end{minted}
		\end{column}
		\begin{column}{0.4\textwidth}
			\begin{minted}{cpp}
try {
    thread t1 = unsafe_executor();
    t1.join();
} catch (const exception& e) {
    cerr << "Error in unsafe_executor: " << e.what() << endl;
}
thread t2 = safe_executor();
t2.join();
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Advanced Parameter Passing}

	\textbf{Member Functions}
	\begin{minted}{cpp}
class X {
public:
    void do_work(int n) {
        cout << "Work " << n
                  << " done by object" << endl;
    }
};

int main() {
    X my_x;

    // Pass member function and object
    thread t(&X::do_work, &my_x, 42);

    t.join();
    return 0;
}
			\end{minted}
\end{frame}

\subsection{Transferring Ownership of a Thread}

\begin{frame}[fragile]{Move Semantics with Threads}
	\textbf{thread is move-only:} Cannot be copied, only moved

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
thread t1(worker);
// Move constructor
thread t2 = move(t1);
// t1 is now empty

// Move from function
thread t3 = create_thread();

// t1.join();  // ERROR! t1 is empty
t2.join();
t3.join();
			\end{minted}
			\textbf{Basic Move Operations}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
thread t1(task1);
thread t2(task2);

// Join first thread
t1.join();

// Move assign - t1 takes over t2
t1 = move(t2);
// t2 is now empty

t1.join();
			\end{minted}
			\textbf{Move Assignment}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Transferring Ownership with Move - Advanced}
	\textbf{Move Semantics:} Transfer unique resources to threads

	\begin{minted}{cpp}
void process_data(unique_ptr<int> ptr) {
    if (ptr) {
        cout << "Processing: " << *ptr << endl;
        *ptr *= 2;
        cout << "Result: " << *ptr << endl;
    }
}

int main() {
    auto ptr = make_unique<int>(42);

    // Transfer ownership to thread using move
    thread t(process_data, move(ptr));

    // ptr is now nullptr, ownership transferred
    assert(ptr == nullptr);

    t.join();
    return 0;
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Thread Containers and RAII}
	\textbf{Managing Multiple Threads with Move Semantics}

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
class scoped_thread {
    thread t;
public:
    explicit scoped_thread(thread t_) : t(move(t_)) {
        if (!t.joinable()) {
            throw logic_error("No thread");
        }
    }

    ~scoped_thread() {
        t.join();
    }

    scoped_thread(const scoped_thread&) = delete;
    scoped_thread& operator=(const scoped_thread&) = delete;
};
            \end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{minted}{cpp}
int main() {
    vector<scoped_thread> threads;

    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(thread(worker, i));
    }

    // Threads automatically joined when scoped_thread destructors run
    return 0;
}
	\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\subsection{Choosing the Number of Threads at Runtime}

\begin{frame}[fragile]{Hardware Concurrency}
	\textbf{thread::hardware\_concurrency():} Get optimal thread count

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{Basic Usage}
			\begin{minted}{cpp}
int main() {
    unsigned int num_threads =
        thread::hardware_concurrency();

    if (num_threads == 0) {
        num_threads = 2;  // Fallback
    }

    cout << "Using " << num_threads
              << " threads" << endl;

    vector<thread> threads;

    for (unsigned int i = 0; i < num_threads; ++i) {
        threads.emplace_back(worker, i);
    }

    for (auto& t : threads) {
        t.join();
    }

    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Parallel Algorithm Example}
			\begin{minted}{cpp}
#include <thread>
#include <vector>
#include <numeric>
#include <iostream>

template<typename Iterator, typename T>
void accumulate_block(Iterator first,
                     Iterator last, T& result) {
    result = accumulate(first, last, result);
}

template<typename Iterator, typename T>
T parallel_accumulate(Iterator first, Iterator last, T init) {
    unsigned long const length = distance(first, last);

    if (!length) return init;

    unsigned long const min_per_thread = 25;
    unsigned long const max_threads =
        (length + min_per_thread - 1) / min_per_thread;

    unsigned long const hardware_threads =
        thread::hardware_concurrency();

    unsigned long const num_threads =
        min(hardware_threads != 0 ?
                 hardware_threads : 2, max_threads);

    unsigned long const block_size = length / num_threads;

    vector<T> results(num_threads);
    vector<thread> threads(num_threads - 1);

    Iterator block_start = first;
    for (unsigned long i = 0; i < (num_threads - 1); ++i) {
        Iterator block_end = block_start;
        advance(block_end, block_size);
        threads[i] = thread(accumulate_block<Iterator, T>,
                                block_start, block_end,
                                ref(results[i]));
        block_start = block_end;
    }
    accumulate_block(block_start, last, results[num_threads - 1]);

    for (auto& entry : threads)
        entry.join();

    return accumulate(results.begin(), results.end(), init);
}
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Dynamic Thread Management}
	\textbf{Example:} Multi-threaded Array Sum with Dynamic Thread Count

	\begin{minted}{cpp}
#include <thread>
#include <vector>
#include <numeric>
#include <iostream>

void partial_sum(const vector<int>& arr, size_t start, size_t end, long long& result) {
    result = 0;
    for(size_t i = start; i < end; i++) {
        result += arr[i];
    }
}

int main() {
    const size_t SIZE = 1000000;
    vector<int> data(SIZE, 1);  // All elements = 1

    // Determine optimal thread count
    unsigned int num_threads = thread::hardware_concurrency();
    if (num_threads == 0) num_threads = 4;  // Fallback

    // Ensure we don't create more threads than needed
    if (num_threads > SIZE) num_threads = SIZE;

    cout << "Using " << num_threads << " threads for " << SIZE << " elements" << endl;

    vector<thread> threads;
    vector<long long> partial_results(num_threads, 0);

    size_t chunk_size = SIZE / num_threads;

    // Create worker threads
    for(unsigned int i = 0; i < num_threads; i++) {
        size_t start = i * chunk_size;
        size_t end = (i == num_threads-1) ? SIZE : (i+1) * chunk_size;

        threads.emplace_back(partial_sum, cref(data),
                           start, end, ref(partial_results[i]));
    }

    // Wait for completion and sum results
    for(auto& t : threads) {
        t.join();
    }

    long long total = accumulate(partial_results.begin(), partial_results.end(), 0LL);

    cout << "Total sum: " << total << endl;
    return 0;
}
	\end{minted}
\end{frame}

\subsection{Identifying Threads}

\begin{frame}[fragile]{Thread IDs}
	\textbf{thread::id:} Unique identifier for each thread

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{Basic Thread ID Usage}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>

void worker() {
    cout << "Thread ID: "
              << this_thread::get_id()
              << endl;
}

int main() {
    cout << "Main thread ID: "
              << this_thread::get_id()
              << endl;

    thread t(worker);

    cout << "Worker thread ID: "
              << t.get_id() << endl;

    t.join();

    cout << "After join, thread ID: "
              << t.get_id() << endl;  // Default-constructed ID

    return 0;
}
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Thread ID Comparison}
			\begin{minted}{cpp}
#include <thread>
#include <iostream>
#include <map>

map<thread::id, string> thread_names;

void name_thread(const string& name) {
    thread_names[this_thread::get_id()] = name;
    cout << "Thread " << name
              << " ID: " << this_thread::get_id()
              << endl;
}

int main() {
    thread_names[this_thread::get_id()] = "main";

    thread t1([](){ name_thread("worker1"); });
    thread t2([](){ name_thread("worker2"); });

    cout << "Main thread: "
              << thread_names[this_thread::get_id()]
              << endl;

    t1.join();
    t2.join();

    return 0;
}
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Thread ID Properties}
	\textbf{Key Properties of thread::id:}

	\begin{itemize}
		\item \textbf{Unique:} Each executing thread has a unique ID
		\item \textbf{Comparable:} Can be compared for equality and ordering
		\item \textbf{Hashable:} Can be used as keys in containers
		\item \textbf{Default-constructible:} Default ID represents "no thread"
	\end{itemize}

	\begin{minted}{cpp}
#include <thread>
#include <iostream>
#include <unordered_set>

int main() {
    thread::id main_id = this_thread::get_id();
    thread::id default_id;  // Default-constructed

    cout << "Main ID == Default ID: "
              << (main_id == default_id) << endl;  // false

    cout << "Default ID == Default ID: "
              << (default_id == thread::id{}) << endl;  // true

    // Use as hash key
    unordered_set<thread::id> thread_set;
    thread_set.insert(main_id);

    thread t([](){
        // Thread IDs are thread-local
        thread::id this_id = this_thread::get_id();
        cout << "Worker thread ID: " << this_id << endl;
    });

    t.join();

    return 0;
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{light-bulb} Best Practices Summary}
	\textbf{Thread Management Checklist:}

	\begin{enumerate}
		\item \textbf{Always handle thread lifecycle:} Call \texttt{join()} or \texttt{detach()}
		\item \textbf{Use RAII:} Wrap threads in guard classes for exception safety
		\item \textbf{Be careful with parameter passing:}
		      \begin{itemize}
			      \item Force conversions before thread creation
			      \item Use \texttt{ref()} for references
			      \item Use \texttt{move()} for unique resources
		      \end{itemize}
		\item \textbf{Avoid the most vexing parse:} Use \texttt{\{\}} or lambdas
		\item \textbf{Choose thread count wisely:} Use \texttt{hardware\_concurrency()}
		\item \textbf{Use thread IDs for debugging:} Identify threads uniquely
	\end{enumerate}

	\vspace{1em}
	\textbf{Key Concepts:}
	\begin{itemize}
		\item \textbf{RAII}: Resource Acquisition Is Initialization
		\item \textbf{Joinable}: Thread can be waited for completion
		\item \textbf{Detached}: Thread runs independently, no control
		\item \textbf{Move-only}: Threads cannot be copied, only moved
		\item \textbf{Thread ID}: Unique identifier for each thread
	\end{itemize}
\end{frame}
