\section{Shared Data Synchronization}

\subsection{Race Conditions}
\begin{frame}[fragile]{\emoji{racing-car} Race Condition Demonstration}
	\textbf{The Problem}: Multiple threads accessing shared data simultaneously

	\begin{minted}[fontsize=\scriptsize]{cpp}
#include <thread>
#include <vector>
#include <iostream>

int counter = 0;  // Shared global variable

void increment_unsafe(int iterations) {
    for(int i = 0; i < iterations; i++) {
        counter++;  // NOT thread-safe!
    }
}

int main() {
    const int NUM_THREADS = 4;
    const int ITERATIONS = 100000;

    std::vector<std::thread> threads;

    // Create threads that increment counter
    for(int i = 0; i < NUM_THREADS; i++) {
        threads.emplace_back(increment_unsafe, ITERATIONS);
    }

    // Wait for all threads to complete
    for(auto& t : threads) {
        t.join();
    }

    std::cout << "Expected: " << NUM_THREADS * ITERATIONS << std::endl;
    std::cout << "Actual:   " << counter << std::endl;
    std::cout << "Lost:     " << (NUM_THREADS * ITERATIONS - counter) << std::endl;

    return 0;
}
	\end{minted}

	\textbf{Expected output}: 400000 \quad \textbf{Typical actual output}: 387234 (varies!)
\end{frame}

\begin{frame}[fragile]{\emoji{microscope} Why Race Conditions Happen}
	\textbf{Assembly Analysis of} \texttt{counter++}:

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{C++ Code}
			\begin{minted}[fontsize=\scriptsize]{cpp}
counter++;
			\end{minted}

			\vspace{1em}
			\textbf{Assembly (x86-64)}
			\begin{minted}[fontsize=\scriptsize]{asm}
mov    eax, DWORD PTR [counter]
add    eax, 1
mov    DWORD PTR [counter], eax
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Thread Interleaving}
			\begin{table}[h]
				\tiny
				\begin{tabular}{|l|l|l|}
					\hline
					\textbf{Thread 1}  & \textbf{Thread 2}  & \textbf{counter} \\
					\hline
					mov eax, [counter] &                    & 0                \\
					(eax = 0)          &                    & 0                \\
					                   & mov eax, [counter] & 0                \\
					                   & (eax = 0)          & 0                \\
					add eax, 1         &                    & 0                \\
					(eax = 1)          &                    & 0                \\
					                   & add eax, 1         & 0                \\
					                   & (eax = 1)          & 0                \\
					mov [counter], eax &                    & 1                \\
					                   & mov [counter], eax & 1                \\
					\hline
				\end{tabular}
			\end{table}

			\textbf{Result}: Both threads read 0, both write 1
			\\Expected: 2, Actual: 1
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{Critical Section}: The portion of code that accesses shared resources
\end{frame}

\subsection{Mutexes and RAII}
\begin{frame}[fragile]{\emoji{lock} From C Mutexes to C++ RAII Locks}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\textbf{C pthread Mutex}
			\begin{minted}[fontsize=\scriptsize]{c}
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int counter = 0;

void* increment_safe(void* arg) {
    int iterations = *(int*)arg;

    for(int i = 0; i < iterations; i++) {
        pthread_mutex_lock(&mutex);
        counter++;  // Critical section
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

// In main: manual cleanup
pthread_mutex_destroy(&mutex);
			\end{minted}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{C++ RAII Lock}
			\begin{minted}[fontsize=\scriptsize]{cpp}
#include <mutex>

std::mutex mtx;
int counter = 0;

void increment_safe(int iterations) {
    for(int i = 0; i < iterations; i++) {
        std::lock_guard<std::mutex> lock(mtx);
        counter++;  // Critical section
        // Automatic unlock when lock goes out of scope
    }
}

// Automatic cleanup - no explicit destroy needed
			\end{minted}
		\end{column}
	\end{columns}

	\vspace{0.5em}
	\textbf{RAII Benefits}:
	\begin{itemize}
		\item \textbf{Exception Safety}: Lock released even if exception thrown
		\item \textbf{No Manual Management}: Automatic acquire/release
		\item \textbf{Scope-based}: Clear lifetime semantics
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\emoji{hammer-and-wrench} Fixed Counter Example}
	\begin{minted}[fontsize=\scriptsize]{cpp}
#include <thread>
#include <vector>
#include <mutex>
#include <iostream>

std::mutex counter_mutex;
int counter = 0;

void increment_safe(int iterations) {
    for(int i = 0; i < iterations; i++) {
        std::lock_guard<std::mutex> lock(counter_mutex);
        counter++;  // Now thread-safe!
    }
}

int main() {
    const int NUM_THREADS = 4;
    const int ITERATIONS = 100000;

    std::vector<std::thread> threads;

    // Create threads
    for(int i = 0; i < NUM_THREADS; i++) {
        threads.emplace_back(increment_safe, ITERATIONS);
    }

    // Wait for completion
    for(auto& t : threads) {
        t.join();
    }

    std::cout << "Expected: " << NUM_THREADS * ITERATIONS << std::endl;
    std::cout << "Actual:   " << counter << std::endl;
    std::cout << "Success:  " << (counter == NUM_THREADS * ITERATIONS ? "Y" : "N") << std::endl;

    return 0;
}
	\end{minted}

	\textbf{Output}: Expected: 400000, Actual: 400000, Success: Y
\end{frame}

\subsection{Deadlock Prevention}
\begin{frame}[fragile]{\emoji{skull} Deadlock: The Four Horsemen}
	\textbf{Deadlock Conditions} (All must be present):
	\begin{enumerate}
		\item \textbf{Mutual Exclusion}: Resources cannot be shared
		\item \textbf{Hold and Wait}: Process holds resource while waiting for another
		\item \textbf{No Preemption}: Resources cannot be forcibly taken
		\item \textbf{Circular Wait}: Circular chain of waiting processes
	\end{enumerate}

	\vspace{1em}
	\textbf{Classic Deadlock Example}:
	\begin{minted}[fontsize=\scriptsize]{cpp}
std::mutex mutex1, mutex2;

void thread1() {
    std::lock_guard<std::mutex> lock1(mutex1);  // Lock mutex1
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> lock2(mutex2);  // Wait for mutex2 (held by thread2)
    // Do work...
}

void thread2() {
    std::lock_guard<std::mutex> lock2(mutex2);  // Lock mutex2
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> lock1(mutex1);  // Wait for mutex1 (held by thread1)
    // Do work...
}
	\end{minted}

	\emoji{warning} \textbf{Result}: Both threads wait forever!
\end{frame}

\begin{frame}[fragile]{\emoji{shield} Deadlock Prevention Strategies}
	\textbf{Strategy 1: Ordered Locking}
	\begin{minted}[fontsize=\scriptsize]{cpp}
std::mutex mutex1, mutex2;

void thread1() {
    std::lock_guard<std::mutex> lock1(mutex1);  // Always lock in same order
    std::lock_guard<std::mutex> lock2(mutex2);
    // Do work...
}

void thread2() {
    std::lock_guard<std::mutex> lock1(mutex1);  // Same order as thread1
    std::lock_guard<std::mutex> lock2(mutex2);
    // Do work...
}
	\end{minted}

	\textbf{Strategy 2: Atomic Multi-lock}
	\begin{minted}[fontsize=\scriptsize]{cpp}
void thread1() {
    std::unique_lock<std::mutex> lock1(mutex1, std::defer_lock);
    std::unique_lock<std::mutex> lock2(mutex2, std::defer_lock);

    std::lock(lock1, lock2);  // Atomic acquisition of both locks
    // Do work...
}  // Automatic release of both locks

void thread2() {
    std::unique_lock<std::mutex> lock1(mutex1, std::defer_lock);
    std::unique_lock<std::mutex> lock2(mutex2, std::defer_lock);

    std::lock(lock1, lock2);  // Same atomic acquisition
    // Do work...
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{\emoji{bank} Practical Example: Bank Transfer}
	\begin{minted}[fontsize=\scriptsize]{cpp}
#include <mutex>
#include <iostream>

class BankAccount {
private:
    double balance;
    mutable std::mutex mtx;

public:
    BankAccount(double initial) : balance(initial) {}

    double get_balance() const {
        std::lock_guard<std::mutex> lock(mtx);
        return balance;
    }

    // Safe transfer using ordered locking
    static void transfer(BankAccount& from, BankAccount& to, double amount) {
        // Ensure consistent lock ordering by address
        if (&from < &to) {
            std::lock_guard<std::mutex> lock1(from.mtx);
            std::lock_guard<std::mutex> lock2(to.mtx);
            from.balance -= amount;
            to.balance += amount;
        } else {
            std::lock_guard<std::mutex> lock1(to.mtx);
            std::lock_guard<std::mutex> lock2(from.mtx);
            from.balance -= amount;
            to.balance += amount;
        }
    }
};

int main() {
    BankAccount alice(1000);
    BankAccount bob(500);

    std::thread t1([&]() { BankAccount::transfer(alice, bob, 100); });
    std::thread t2([&]() { BankAccount::transfer(bob, alice, 50); });

    t1.join();
    t2.join();

    std::cout << "Alice: $" << alice.get_balance() << std::endl;
    std::cout << "Bob: $" << bob.get_balance() << std::endl;

    return 0;
}
	\end{minted}
\end{frame}
